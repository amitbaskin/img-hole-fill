package img_hole_fill.algos;

import img_hole_fill.utils.IntPair;
import java.util.HashSet;

/**
 * Choosing log(n) (where n is the number of pixels in the hole to fill) representatives from the boundary of
 * the hole and using them to fill the entire hole. The goal here is to achieve the solution in O(nlog(n))
 * instead of O(n^2) as in the basic solution.
 */
public class RandBoundaryAlgo extends RandAlgo implements FillHoleAlgo{

    /**
     * Factory for the class
     * @return An instance of this class
     */
    public static RandBoundaryAlgo getRandBoundaryAlgoInstance(){
        return new RandBoundaryAlgo();
    }

    /**
     * Hiding the constructor
     */
    private RandBoundaryAlgo(){}

    /**
     * Applying the algorithm to fill the hole
     * @param grayMat The matrix to fill its values
     * @param holeSet The pixels in the hole
     * @param boundarySet The pixels in the boundary
     * @param func The weighting function to use while calculating the values to fill with
     * @param isEightConnected Whether or not to apply the 8-connected approach (4-connected is the default)
     */
    @Override
    public void apply(float[][] grayMat, HashSet<IntPair> holeSet, HashSet<IntPair> boundarySet,
                      WeightFunction func, boolean isEightConnected) {
        initHelper(boundarySet);
        BaseAlgo.getInstance().apply(grayMat, holeSet, repsSet, func, isEightConnected);
    }

    /**
     * This is used in the writing of the result generated by this algo. The output string will be
     * part of the name of the output image.
     * @return The string that should be concatenated with the file name of the output image generated by
     * this algo
     */
    @Override
    public String toString(){
        return "RandBoundaryAlgo";
    }
}
